package internal

import (
	"encoding/xml"
	"fmt"
	"os/exec"
	"strings"
	"sync"
)

// PackageMetadata represents the metadata of a package generated by ypkg
type PackageMetadata struct {
	XMLName xml.Name `xml:"PISI"`
	Package Package
}

// RuntimeDependencies represents package dependencies used at runtime
type RuntimeDependencies struct {
	Dependencies []Dependency `xml:"Dependency"`
}

// Package represents one of the eopkg archives generated by ypkg
type Package struct {
	Name                string
	Component           string
	RuntimeDependencies RuntimeDependencies
}

// NewPackage returns a fully instanciated package from eopkg information
func NewPackage(name string) (p *Package, err error) {
	cmd := []string{
		"eopkg",
		"info",
		"--xml",
		name,
	}

	o, err := exec.Command(cmd[0], cmd[1:]...).Output()
	if err != nil {
		if err.Error() == "exit status 1" {
			return nil, fmt.Errorf("Package %s does not exists", name)
		}

		return
	}

	metadata := &PackageMetadata{}

	r := strings.NewReader(string(o))
	dec := xml.NewDecoder(r)
	err = dec.Decode(metadata)
	if err != nil {
		return
	}

	return &metadata.Package, nil
}

// DependencyGraph returns the dependency graph of a package
func (p *Package) DependencyGraph() (d *DependencyGraph, err error) {
	d = &DependencyGraph{}
	err = p.lookupDependencies(d, make(map[string]bool))
	return
}

func (p *Package) DependencyGraphThread() (d *DependencyGraph, err error) {
	var wg sync.WaitGroup

	d = &DependencyGraph{}
	err = p.lookupDependenciesThread(d, make(map[string]bool), &wg)

	wg.Wait()

	return
}

func (p Package) DependencyGraphDFS() (d *DependencyGraph, err error) {
	d = &DependencyGraph{}
	stack := Stack{}
	seen := make(map[string]bool)

	stack.Push(p)

	for !stack.IsEmpty() {
		current := stack.Pop()
		dependency := &Dependency{current.Name}

		if _, ok := seen[current.Name]; !ok {
			seen[current.Name] = true
			d.AddNode(dependency)

			for _, childDep := range current.RuntimeDependencies.Dependencies {
				// This is needed to avoid overriding fields in the struct when lock is
				// not released before the loop goes to the next value
				childDep := childDep
				d.AddEdge(dependency, &childDep)
			}
		}

		for _, childDep := range current.RuntimeDependencies.Dependencies {
			// This is needed to avoid overriding fields in the struct when lock is
			// not released before the loop goes to the next value
			childDep := childDep
			if _, ok := seen[childDep.Name]; !ok {
				var childPackage *Package
				childPackage, err = NewPackage(childDep.Name)
				if err != nil {
					return
				}
				stack.Push(*childPackage)
			}
		}
	}

	return
}

func (p Package) DependencyGraphDFSThread() (d *DependencyGraph, err error) {
	var wg sync.WaitGroup

	d = &DependencyGraph{}
	stack := Stack{}
	seen := make(map[string]bool)

	stack.Push(p)
	for !stack.IsEmpty() {
		current := stack.Pop()
		dependency := &Dependency{current.Name}

		if _, ok := seen[current.Name]; !ok {
			seen[current.Name] = true
			d.AddNode(dependency)

			for _, childDep := range current.RuntimeDependencies.Dependencies {
				// This is needed to avoid overriding fields in the struct when lock is
				// not released before the loop goes to the next value
				childDep := childDep
				d.AddEdge(dependency, &childDep)
			}
		}

		for _, childDep := range current.RuntimeDependencies.Dependencies {
			childDep := childDep
			wg.Add(1)
			go func(childDep Dependency) {
				defer wg.Done()

				// This is needed to avoid overriding fields in the struct when lock is
				// not released before the loop goes to the next value
				if _, ok := seen[childDep.Name]; !ok {
					var childPackage *Package
					childPackage, err = NewPackage(childDep.Name)
					if err != nil {
						return
					}
					stack.Push(*childPackage)
				}
			}(childDep)
		}

		wg.Wait()
	}

	return
}

func (p Package) DependencyGraphBFS() (d *DependencyGraph, err error) {
	d = &DependencyGraph{}
	queue := make(chan Package, 300)
	seen := make(map[string]bool)

	queue <- p

	for len(queue) != 0 {
		current := <-queue
		dependency := &Dependency{current.Name}

		if _, ok := seen[current.Name]; !ok {
			seen[current.Name] = true
			d.AddNode(dependency)

			for _, childDep := range current.RuntimeDependencies.Dependencies {
				// This is needed to avoid overriding fields in the struct when lock is
				// not released before the loop goes to the next value
				childDep := childDep
				d.AddEdge(dependency, &childDep)
			}
		}

		for _, childDep := range current.RuntimeDependencies.Dependencies {
			// This is needed to avoid overriding fields in the struct when lock is
			// not released before the loop goes to the next value
			childDep := childDep
			if _, ok := seen[childDep.Name]; !ok {
				var childPackage *Package
				childPackage, err = NewPackage(childDep.Name)
				if err != nil {
					return
				}

				queue <- *childPackage
			}
		}
	}

	return
}

func (p Package) DependencyGraphBFSThread() (d *DependencyGraph, err error) {
	var wg sync.WaitGroup

	d = &DependencyGraph{}
	queue := make(chan Package, 300)
	seen := make(map[string]bool)

	queue <- p

	for len(queue) != 0 {
		current := <-queue
		dependency := &Dependency{current.Name}

		if _, ok := seen[current.Name]; !ok {
			seen[current.Name] = true
			d.AddNode(dependency)

			for _, childDep := range current.RuntimeDependencies.Dependencies {
				// This is needed to avoid overriding fields in the struct when lock is
				// not released before the loop goes to the next value
				childDep := childDep
				d.AddEdge(dependency, &childDep)
			}
		}

		for _, childDep := range current.RuntimeDependencies.Dependencies {
			// This is needed to avoid overriding fields in the struct when lock is
			// not released before the loop goes to the next value
			childDep := childDep
			wg.Add(1)
			go func(childDep Dependency) {
				defer wg.Done()
				if _, ok := seen[childDep.Name]; !ok {
					var childPackage *Package
					childPackage, err = NewPackage(childDep.Name)
					if err != nil {
						return
					}

					queue <- *childPackage
				}
			}(childDep)
		}

		wg.Wait()
	}

	return
}

// LookupDependencies looks for a package dependencies and add them to the graph
func (p *Package) lookupDependencies(graph *DependencyGraph, visited map[string]bool) error {
	root := Dependency{p.Name}

	visited[p.Name] = true
	graph.AddNode(&root)

	for _, dependency := range p.RuntimeDependencies.Dependencies {
		// This is needed to avoid overriding fields in the struct when lock is
		// not released before the loop goes to the next value
		dependency := dependency
		graph.AddEdge(&root, &dependency)

		// Do not revisit already visited nodes
		if visited[dependency.Name] == true {
			continue
		}

		var dependencyData *Package
		dependencyData, err := NewPackage(dependency.Name)
		if err != nil {
			return err
		}

		err = dependencyData.lookupDependencies(graph, visited)
		if err != nil {
			return err
		}
	}

	return nil
}

// FIXME: This one repeat threads
func (p *Package) lookupDependenciesThread(graph *DependencyGraph, visited map[string]bool, wg *sync.WaitGroup) error {
	root := Dependency{p.Name}

	visited[p.Name] = true
	graph.AddNode(&root)

	for _, dependency := range p.RuntimeDependencies.Dependencies {
		// This is needed to avoid overriding fields in the struct when lock is
		// not released before the loop goes to the next value
		dependency := dependency
		graph.AddEdge(&root, &dependency)

		// Do not revisit already visited nodes
		if visited[dependency.Name] == true {
			continue
		}

		wg.Add(1)
		go func(dependency Dependency) {
			defer wg.Done()

			var dependencyData *Package
			dependencyData, err := NewPackage(dependency.Name)
			if err != nil {
				return
			}

			err = dependencyData.lookupDependenciesThread(graph, visited, wg)
			if err != nil {
				return
			}
		}(dependency)
	}

	return nil
}
