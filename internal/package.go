package internal

import (
	"encoding/xml"
	"fmt"
	"os/exec"
	"strings"
)

// PackageMetadata represents the metadata of a package generated by ypkg
type PackageMetadata struct {
	XMLName xml.Name `xml:"PISI"`
	Package Package
}

// RuntimeDependencies represents package dependencies used at runtime
type RuntimeDependencies struct {
	Dependencies []Dependency `xml:"Dependency"`
}

// Package represents one of the eopkg archives generated by ypkg
type Package struct {
	Name                string
	Component           string
	RuntimeDependencies RuntimeDependencies
}

// NewPackage returns a fully instanciated package from eopkg information
func NewPackage(name string) (p *Package, err error) {
	cmd := []string{
		"eopkg",
		"info",
		"--xml",
		name,
	}

	o, err := exec.Command(cmd[0], cmd[1:]...).Output()
	if err != nil {
		if err.Error() == "exit status 1" {
			return nil, fmt.Errorf("Package %s does not exists", name)
		}

		return
	}

	metadata := &PackageMetadata{}

	r := strings.NewReader(string(o))
	dec := xml.NewDecoder(r)
	err = dec.Decode(metadata)
	if err != nil {
		return
	}

	return &metadata.Package, nil
}

// DependencyGraph returns the dependency graph of a package
func (p *Package) DependencyGraph() (d *DependencyGraph, err error) {
	d = &DependencyGraph{}
	err = p.lookupDependencies(d, make(map[string]bool))
	return
}

// LookupDependencies looks for a package dependencies and add them to the graph
func (p *Package) lookupDependencies(graph *DependencyGraph, visited map[string]bool) error {
	root := Dependency{p.Name}

	visited[p.Name] = true
	graph.AddNode(&root)

	for _, dependency := range p.RuntimeDependencies.Dependencies {
		// This is needed to avoid overriding fields in the struct when lock is
		// not released before the loop goes to the next value
		dependencyCopy := dependency

		// Do not revisit already visited nodes
		if visited[dependencyCopy.Name] == true {
			continue
		}

		graph.AddEdge(&root, &dependencyCopy)

		var dependencyData *Package
		dependencyData, err := NewPackage(dependencyCopy.Name)
		if err != nil {
			return err
		}

		err = dependencyData.lookupDependencies(graph, visited)
		if err != nil {
			return err
		}
	}

	return nil
}
